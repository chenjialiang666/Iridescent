{"title":"CF339E Three Swaps","file":"CF339E.json","pic":"/bg/53.jpg","tag":["暴力"],"priority":0,"source":"CF","link":[["LG","https://www.luogu.com.cn/problem/CF339E"],["CF","https://codeforces.com/problemset/problem/339/E"]],"pswd":false,"date":"2021-06-25 13:02","content":"## 题面翻译\n\n一个排列：$a_1,a_2......a_n$​,你可以翻转区间 $[l,r]$\n\n你需要在三步以内，将 $1,2,3,\\cdots,n$ 的排列翻转成排列a\n\n\n## 题解\n\n一步交换最多产生两个点使得 $|a_i-a_{i-1}|\\neq1\\quad \\text{or}\\quad |a_{i}-a{i+1}|\\neq1$，因此最多有 $6$ 个这样的\n点，枚举这样的点对并进行 $\\rm dfs$ 即可。\n\n## 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+10;\nint n,a[N];\nint l[N],r[N];\nvoid dfs(int now){\n\tbool flag=1;\n\tfor(int i=1;i<=n;i++)\n\t\tflag&=(i==a[i]);\n\tif(flag){\n\t\tprintf(\"%d\\n\",now);\n\t\tfor(int i=now;i>=1;i--)\n\t\t\tprintf(\"%d %d\\n\",l[i],r[i]);\n\t\texit(0);\n\t}\n\tif(now<=2){\n\t\tint w[80],cnt=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(abs(a[i]-a[i-1])!=1||abs(a[i]-a[i+1])!=1)\n\t\t\t\tw[++cnt]=i;\n\t\tfor(int i=1;i<=cnt;i++)\n\t\t\tfor(int j=i+1;j<=cnt;j++){\n\t\t\t\treverse(&a[w[i]],&a[w[j]]+1);\n\t\t\t\tl[now+1]=w[i],r[now+1]=w[j];\n\t\t\t\tdfs(now+1);\n\t\t\t\treverse(&a[w[i]],&a[w[j]]+1);\n\t\t\t}\n\t}\n}\nsigned main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\ta[n+1]=n+1;\n\tdfs(0);\n}\n```"}