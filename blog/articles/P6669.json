{"title":"P6669 [清华集训2016] 组合数问题","file":"P6669.json","pic":"/bg/146.jpg","tag":["数位dp","Lucas"],"priority":0,"source":"LG","link":[["LG","https://www.luogu.com.cn/problem/P6669"]],"pswd":false,"date":"2021-06-24 20:36","content":"## 题目描述\n\n组合数 $C_n^m$ 表示的是从 $n$ 个物品中选出 $m$ 个物品的方案数。举个例子，从 $(1,2,3)$ 三个物品中选择两个物品可以有 $(1,2),(1,3),(2,3)$ 这三种选择方法。根据组合数的定义，我们可以给出计算组合数 $C_n^m$ 的一般公式：\n\n$$C_n^m=\\dfrac{n!}{m!(n-m)!}$$\n\n其中 $n!=1×2×⋯×n$。（额外的，当 $n=0$ 时，$n!=1$）\n\n小葱想知道如果给定 $n,m$ 和 $k$，对于所有的 $0≤i≤n,0≤j≤\\min(i,m)$ 有多少对 $(i,j)$ 满足 $C^j_i$ 是 $k$ 的倍数。\n\n答案对 $10^9+7$ 取模。\n\n## 输入格式\n\n第一行有两个整数 $t,k$，其中 $t$ 代表该测试点总共有多少组测试数据。\n\n接下来 $t$ 行每行两个整数 $n,m$。\n\n## 输出格式\n\n$t$ 行，每行一个整数代表所有的 $0≤i≤n,0≤j≤\\min(i,m)$ 中有多少对 $(i,j)$ 满足 $C^j_i$ 是 $k$ 的倍数。\n\n## 限制与约定\n\n对于 $20\\%$ 的测试点，$1≤n,m≤100$；\n\n对于另外 $15\\%$ 的测试点，$n≤m$；\n\n对于另外 $15\\%$ 的测试点，$k=2$；\n\n对于另外 $15\\%$ 的测试点， $m\\le10$；\n\n对于 $100\\%$ 的测试点， $1≤n,m≤10^{18}$，$1≤t,k≤100$，且 $k$ 是一个质数。\n\n## 题解\n\n考虑：\n$$\nk|\\binom nm\\Longleftrightarrow \\binom nm\\equiv 0\\bmod k\\Longleftrightarrow\\prod\\binom{bn_i}{bm_i}\\equiv0\\bmod k\n$$\n直接反面令其不等于 $0$，也即 $\\forall i,bm_i\\le bn_i$，数位 $\\rm dp$ 即可\n\n## 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<const int mod>\nstruct modint{\n    int x;\n    modint<mod>(int o=0){x=o;}\n    modint<mod> &operator = (int o){return x=o,*this;}\n    modint<mod> &operator +=(modint<mod> o){return x=x+o.x>=mod?x+o.x-mod:x+o.x,*this;}\n    modint<mod> &operator -=(modint<mod> o){return x=x-o.x<0?x-o.x+mod:x-o.x,*this;}\n    modint<mod> &operator *=(modint<mod> o){return x=1ll*x*o.x%mod,*this;}\n    modint<mod> &operator +=(int o){return x=x+o>=mod?x+o-mod:x+o,*this;}\n    modint<mod> &operator -=(int o){return x=x-o<0?x-o+mod:x-o,*this;}\n    modint<mod> &operator *=(int o){return x=1ll*x*o%mod,*this;}\n    template<class I>friend modint<mod> operator +(modint<mod> a,I b){return a+=b;}\n    template<class I>friend modint<mod> operator -(modint<mod> a,I b){return a-=b;}\n    template<class I>friend modint<mod> operator *(modint<mod> a,I b){return a*=b;}\n};\nconst int mod=1000000007;\ntypedef long long ll;\ntypedef modint<mod> mint;\nconst mint inv2=500000004;\nmint dp[80][2][2];\nll n,m;mint N,M;\nint k,p1[80],cnt1,p2[80],cnt2;\nvoid pre(ll x,int*p,int&cnt){\n\tcnt=0;memset(p,0,80*4);\n\twhile(x)p[++cnt]=x%k,x/=k;\n}\nmint dfs(int now,bool flag1,bool flag2){\n\tif(!now)return 1;\n\tif(dp[now][flag1][flag2].x!=-1)return dp[now][flag1][flag2];\n\tint up1=k-1,up2=k-1;\n\tif(flag1)up1=p1[now];\n\tif(flag2)up2=p2[now];\n\tmint ans=0;\n\tfor(int i=0;i<=up1;i++)\n\t\tfor(int j=0;j<=up2&&j<=i;j++)\n\t\t\tans+=dfs(now-1,flag1&&i==up1,flag2&&j==up2);\n\treturn dp[now][flag1][flag2]=ans;\n}\nmint calc(ll n,ll m){\n\tpre(n,p1,cnt1);\n\tpre(m,p2,cnt2);\n\tmemset(dp,0xff,sizeof dp);\n\treturn dfs(cnt1,1,1);\n}\nsigned main(){\n\tint t;scanf(\"%d%d\",&t,&k);\n\twhile(t--){\n\t\tscanf(\"%lld%lld\",&n,&m);\n\t\tif(m>n)m=n;\n\t\tN=n%mod,M=m%mod;\n\t\tmint ans=(M+1)*M*inv2+(N-M)*M+N+1-calc(n,m);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n```"}