{"title":"CF266E More Queries to Array...","file":"CF266E.json","pic":"/bg/9.jpg","tag":["线段树","二项式定理"],"priority":0,"source":"CF","link":[["LG","https://www.luogu.com.cn/problem/CF266E"],["CF","https://codeforces.com/problemset/problem/266/E"]],"pswd":false,"date":"2021-06-28 13:11","content":"## 题面翻译\n\n一段序列 $a_1,a_2......a_n$  \n\n两种操作：  \n\n$=\\ l\\ r\\ x$ 表示将区间 $[l,r]$ 的值赋为 $x$  \n$?\\ l\\ r\\ k$ 表示输出 $\\sum_{i=l}^ra_i(i-l+1)^k\\bmod 10^9+7$\n\n## 题解\n\n看上去要维护一个很高大上的东西，实际上：\n$$\n\\sum_{i=l}^ra_i(i-l+1)^k=\\sum_{i=l}^ra_i\\sum_{j=0}^k\\binom kji^j(1-l)^{k-j}\n\\\\=\\sum_{j=0}^k\\binom kj(1-l)^{k-j}\\sum_{i=l}^ra_ii^j\n$$\n由于 $k\\le5$，实现一棵能区间覆盖的线段树即可。\n\n## 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<const int mod>\nstruct modint{\n    int x;\n    modint<mod>(int o=0){x=(o%mod+mod)%mod;}\n    modint<mod> &operator = (int o){return x=o,*this;}\n    modint<mod> &operator +=(modint<mod> o){return x=x+o.x>=mod?x+o.x-mod:x+o.x,*this;}\n    modint<mod> &operator -=(modint<mod> o){return x=x-o.x<0?x-o.x+mod:x-o.x,*this;}\n    modint<mod> &operator *=(modint<mod> o){return x=1ll*x*o.x%mod,*this;}\n    modint<mod> &operator +=(int o){return x=x+o>=mod?x+o-mod:x+o,*this;}\n    modint<mod> &operator -=(int o){return x=x-o<0?x-o+mod:x-o,*this;}\n    modint<mod> &operator *=(int o){return x=1ll*x*o%mod,*this;}\n    template<class I>friend modint<mod> operator +(modint<mod> a,I b){return a+=b;}\n    template<class I>friend modint<mod> operator -(modint<mod> a,I b){return a-=b;}\n    template<class I>friend modint<mod> operator *(modint<mod> a,I b){return a*=b;}\n};\ntypedef modint<1000000007>mint;\nconst int N=1e5+10;\nint n,m,a[N];\nmint c[6][6],s[6][N];\nvoid pre(){\n\tc[0][0]=1;\n\tfor(int i=1;i<=5;i++){\n\t\tc[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tc[i][j]=c[i-1][j-1]+c[i-1][j];\n\t}\n\tfor(int i=1;i<=n;i++)s[0][i]=1;\n\tfor(int j=1;j<=5;j++)\n\t\tfor(int i=1;i<=n;i++)\n\t\t\ts[j][i]=s[j-1][i]*i;\n\tfor(int j=0;j<=5;j++)\n\t\tfor(int i=1;i<=n;i++)\n\t\t\ts[j][i]+=s[j][i-1];\n}\n#define sum(k,l,r) (s[k][r]-s[k][l-1])\n#define lc (x<<1)\n#define rc (x<<1|1)\n#define mid (l+r>>1)\nint l[N<<2],r[N<<2],tag[N<<2];\nmint val[6][N<<2];\nvoid down(int x){\n\tif(tag[x]!=-1){\n\t\ttag[lc]=tag[x];\n\t\tfor(int i=0;i<=5;i++)\n\t\t\tval[i][lc]=sum(i,l[lc],r[lc])*tag[x];\n\t\t\t\n\t\ttag[rc]=tag[x];\n\t\tfor(int i=0;i<=5;i++)\n\t\t\tval[i][rc]=sum(i,l[rc],r[rc])*tag[x];\n\t\t\n\t\ttag[x]=-1;\n\t}\n}\nvoid up(int x){\n\tfor(int i=0;i<=5;i++) \n\t\tval[i][x]=val[i][lc]+val[i][rc];\n}\nvoid build(int x,int l,int r){\n\t::l[x]=l,::r[x]=r,::tag[x]=-1;\n\tif(l==r){\n\t\tfor(int i=0;i<=5;i++)\n\t\t\tval[i][x]=mint(a[l])*sum(i,l,l);\n\t\treturn;\n\t}\n\tbuild(lc,l,mid);\n\tbuild(rc,mid+1,r);\n\tup(x);\n}\n#define l l[x]\n#define r r[x]\nvoid upd(int x,int ql,int qr,int v){\n\tif(ql<=l&&r<=qr){\n\t\ttag[x]=v;\n\t\tfor(int i=0;i<=5;i++)\n\t\t\tval[i][x]=sum(i,l,r)*v;\n\t\treturn;\n\t}\n\tdown(x);\n\tif(ql<=mid)upd(lc,ql,qr,v);\n\tif(mid<qr)upd(rc,ql,qr,v);\n\tup(x);\n}\nmint qry(int x,int ql,int qr,int k){\n\tif(ql<=l&&r<=qr)return val[k][x];\n\tif(r<ql||l>qr)return 0;\n\tdown(x);\n\treturn qry(lc,ql,qr,k)+qry(rc,ql,qr,k);\n}\n#undef l\n#undef r\nsigned main(){\n\tscanf(\"%d%d\",&n,&m);\n\tpre();\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tbuild(1,1,n);\n\twhile(m--){\n\t\tchar op=getchar();\n\t\twhile(op!='?'&&op!='=')\n\t\t\top=getchar();\n\t\tif(op=='='){\n\t\t\tint l,r,x;scanf(\"%d%d%d\",&l,&r,&x);\n\t\t\tupd(1,l,r,x);\n\t\t}else{\n\t\t\tint l,r,k;scanf(\"%d%d%d\",&l,&r,&k);\n\t\t\tmint a=(1-l),ans=0,kk=1;\n\t\t\tfor(int i=0;i<=k;i++)\n\t\t\t\tans+=c[k][i]*qry(1,l,r,k-i)*kk,kk*=a;\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n} \n```"}