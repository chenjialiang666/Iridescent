{"title":"CF323C Two permutations","file":"CF323C.json","pic":"/bg/14.jpg","tag":["主席树"],"priority":0,"source":"CF","link":[["LG","https://www.luogu.com.cn/problem/CF323C"],["CF","https://codeforces.com/problemset/problem/323/C"]],"pswd":false,"date":"2021-06-29 20:24","content":"## 题面翻译\n\n- 给定两个长度均为 $n$ 的 **排列**。\n- $m$ 次询问。每次询问您要求出在第一个排列的 $[l_1,r_1]$ 和第二个排列的 $[l_2,r_2]$ 同时出现的数有多少个。\n- $1\\le n\\le 10^6$，$1\\le m\\le 2\\times 10^5$。强制在线。\n## 题解\n比较显然的题目，记 $pos[a[i]]=i$，问题等价于在 $[l_2,r_2]$ 有多少 $pos\\in[l_1,r_1]$ 的。于是主席树随便搞一下前缀和就做完了。\n## 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+10;\nint n,a[N],b[N],pos[N],m;\nint s[N<<5],lc[N<<5],rc[N<<5];\nint rt[N];\nint cnt;\n#define mid (l+r>>1)\nvoid upd(int&x,int lst,int l,int r,int pos){\n\tx=++cnt;\n\tlc[x]=lc[lst];\n\trc[x]=rc[lst];\n\ts[x]=s[lst]+1;\n\tif(l==r)return;\n\tif(pos<=mid)upd(lc[x],lc[lst],l,mid,pos);\n\telse upd(rc[x],rc[lst],mid+1,r,pos);\n}\nint qry(int x,int l,int r,int ql,int qr){\n\tif(ql<=l&&r<=qr)return s[x];\n\tif(qr<l||r<ql)return 0;\n\treturn qry(lc[x],l,mid,ql,qr)+qry(rc[x],mid+1,r,ql,qr);\n}\nsigned main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]),pos[a[i]]=i;\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&b[i]),upd(rt[i],rt[i-1],1,n,pos[b[i]]);\n\tscanf(\"%d\",&m);int ans=0;\n\twhile(m--){\n\t\t#define f(z) (z-1+ans)%n+1\n\t\tint a,b,c,d;scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tint l1=min(f(a),f(b)),r1=max(f(a),f(b));\n\t\tint l2=min(f(c),f(d)),r2=max(f(c),f(d));\n\t\tans=qry(rt[r2],1,n,l1,r1)-qry(rt[l2-1],1,n,l1,r1);\n\t\tprintf(\"%d\\n\",ans++);\n\t}\n}\n```"}