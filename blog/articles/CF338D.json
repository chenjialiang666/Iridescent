{"title":"CF338D GCD Table","file":"CF338D.json","pic":"/bg/14.jpg","tag":["excrt"],"priority":0,"source":"CF","link":[["LG","https://www.luogu.com.cn/problem/CF338D"],["CF","http://codeforces.com/problemset/problem/338/D"]],"pswd":false,"date":"2021-06-28 20:07","content":"## 题面翻译\n\n一张$n\\times m$ 的表，第$i$ 行第$j$ 列是$GCD(i,j)$   \n你有一个长度为$k$ 的数列$a$ ，询问是否存在$i,j$ ，满足对任意的$l$ ，均有$GCD(i,j+l-1)=a_l(1\\leq l\\leq k)$ 。\n\n## 题解\n\n记 $M=\\operatorname{lcm}_{i=1}^k a_i$，显然要满足 $M|i$，以及：\n$$\n\\begin{cases}\nj\\equiv 0\\pmod{a_1}\\\\\nj\\equiv -1\\pmod{a_2}\\\\\n\\dots\\\\\nj\\equiv -k+1\\pmod{a_k}\\\\\n\\end{cases}\n$$\n解出来 $j\\equiv ans\\pmod M$ \n\n第二个就是 $\\rm exCRT$。不难发现 $i=M$ 时最优，因为上面的条件必定是必要的。那么 $i=M$ 必定比 $i=k\\times M$ 时更容易 $\\gcd(\\frac ia,\\frac ja)=1$。\n\n至于 $j$，显然当 $i=M$ 时 $\\gcd(i,j)=\\gcd(i,j+L)$，为了让 $j$ 尽可能小取 $ans$\n\n## 代码\n```cpp\n#include<bits/stdc++.h>\n#define Bye puts(\"NO\"),exit(0)\nusing namespace std;\nconst int N=100000+10;\ntypedef long long ll;\nint n;\nll xx,yy;\nll a[N],b[N],ans,M;\nll ksc(ll n,ll k,ll mod){\n\tll ans=0;\n\twhile(k){\n\t\tif(k&1)ans+=n,ans%=mod;\n\t\tk>>=1;\n\t\tn*=2;n%=mod;\n\t}return ans;\n}\nll exgcd(ll a,ll b,ll&x,ll&y){\n\tif(!b){x=1,y=0;return a;}\n\tll d=exgcd(b,a%b,x,y);\n\tll z=x;x=y;y=z-(a/b)*y;\n\treturn d;\n}\nll gcd(ll a,ll b){\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\nll CRT(){\n\tll x,y;\n\tans=a[1];M=b[1];\n\tfor(int i=2;i<=n;i++){\n\t\tll B=((a[i]-ans)%b[i]+b[i])%b[i];\n\t\tll GCD=exgcd(M,b[i],x,y);\n\t\tif(B%GCD)Bye;\n\t\tx=ksc(x,B/GCD,b[i]);\n\t\tans+=M*x;\n\t\tM*=b[i]/GCD;\n\t\tans=(ans+M)%M;\n\t}return (ans+M-1)%M+1;\n}\nsigned main(){\n\tscanf(\"%lld%lld%d\",&xx,&yy,&n);\n\tM=1;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&b[i]);\n\t\ta[i]=-i+1;\n\t\ta[i]%=b[i];\n\t\ta[i]+=b[i];\n\t\ta[i]%=b[i];\n\t\tM*=b[i]/gcd(M,b[i]);\n\t\tif(M>xx)Bye;\n\t}\n\tll i=M;ll j=CRT();\n\tif(j+n-1>yy)Bye;\n\tfor(int l=1;l<=n;l++)\n\t\tif(gcd(i,j+l-1)!=b[l])Bye;\n\tputs(\"YES\");\n}\n```"}