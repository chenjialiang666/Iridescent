{"title":"CF311C Fetch the Treasure","file":"CF311C.json","pic":"/bg/61.jpg","tag":["同余最短路"],"priority":0,"source":"CF","link":[["LG","https://www.luogu.com.cn/problem/CF311C"],["CF","http://codeforces.com/problemset/problem/311/C"]],"pswd":false,"date":"2021-06-29 16:33","content":"## 题面翻译\n\n有 $n$ 个二元组 $(x,y)$，一个集合 $S$。初始时 $S$ 中只有一个元素 $k$。若一个二元组满足 $x=1+\\sum\\limits_{i=1}^{|S|}k_i \\cdot S_i(k_i \\in \\mathbf{N}^*)$，则将这个二元组放入集合 $Q$ 中。要求支持如下三种操作：\n1. 向 $S$ 中增加一个元素 $x$。\n2. 将第 $x$ 个二元组的 $y$ 值减小 $d$。\n3. 查询 $Q$ 集合中 $y$ 值最大的二元组，输出其 $y$ 值并将其删除。\n\n保证 1 操作不超过 20 次。\n\n\n## 题解\n发现转化一下题意就是问 $x$ 能否用 $S$ 中的数构成，其中 $|S|\\le20,\\min S\\le 10^4$。\n\n先把 $\\min S$ 即 $k$，拿出来，按膜 $k$ 的余数分为 $k$ 组。每一组一定是前一段不能构成，之后全部能构成。在这 $k$ 个数之间连边，对 $i\\to i+x\\bmod k(x\\in S)$ 连边，边权为 $\\lfloor\\frac{i+x}k\\rfloor$。从 $1$ 跑一遍最短路就能得到第一个能构成的数了。\n\n于是用数据结构随便维护一下就好了。\n## 代码\n```cpp\n#include<bits/stdc++.h>\n#define int ll\nusing namespace std;\ntypedef long long ll;\nnamespace Graph{\n\tconst int N=1e4+10;\n\tll dis[N];bool vis[N];\n\tvector<pair<ll,int>>E[N];\n\tvoid init(){\n\t\tfor(int i=0;i<N;i++)E[i].clear();\n\t\tmemset(dis,0x7f,sizeof dis); \n\t\tmemset(vis,0,sizeof vis);\n\t}\n\tvoid add(int u,int v,ll w){\n\t\tE[u].push_back({v,w});\n\t}\n\tvoid Dij(int s=1){\n\t\tdis[s]=0;\n\t\tpriority_queue<pair<ll,int>>q;q.push({0,s});\n\t\twhile(q.size()){\n\t\t\tint u=q.top().second;q.pop();\n\t\t\tif(vis[u])continue;vis[u]=1;\n\t\t\tfor(auto [v,w]:E[u])\n\t\t\t\tif(dis[v]>dis[u]+w)\n\t\t\t\t\tdis[v]=dis[u]+w,q.push({-dis[v],v});\n\t\t}\n\t}\n}\nconst int N=1e5+10;\nll a[N];ll c[N];\npriority_queue<pair<int,int>>q;\nint n,m;ll h;\nint k;vector<ll>s;\nvoid Deal(){\n\twhile(q.size())q.pop();\n\tGraph::init();\n\tfor(int i=0;i<k;i++){\n\t\tfor(auto v:s)\n\t\t\tGraph::add(i,(i+v)%k,(i+v)/k);\n\t}\n\tGraph::Dij();\n\tfor(int i=1;i<=n;i++)\n\t\tif(c[i]/k>=Graph::dis[c[i]%k])\n\t\t\tq.push({a[i],-i});\n}\nsigned main(){\n\tscanf(\"%lld%lld%lld%lld\",&h,&n,&m,&k);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lld%lld\",&c[i],&a[i]); \n\tDeal();\n\twhile(m--){\n\t\tint op;scanf(\"%lld\",&op);\n\t\tif(op==1){\n\t\t\tint x;scanf(\"%lld\",&x);\n\t\t\ts.push_back(x);Deal();\n\t\t}else if(op==2){\n\t\t\tint x,y;scanf(\"%lld%lld\",&x,&y);\n\t\t\ta[x]-=y;\n\t\t}else{\n\t\t\tif(!q.size()){\n\t\t\t\tputs(\"0\");continue;}\n\t\t\tauto p=q.top();q.pop();\n\t\t\twhile(a[-p.second]!=p.first){\n\t\t\t\tp.first=a[-p.second];q.push(p);\n\t\t\t\tp=q.top(),q.pop();\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",p.first);\n\t\t\tp.first=a[-p.second]=0;\n\t\t\tq.push(p);\n\t\t}\n\t}\n}\n```"}