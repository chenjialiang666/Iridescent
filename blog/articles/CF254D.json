{"title":"CF254D Rats","file":"CF254D.json","pic":"/bg/123.jpg","tag":["暴力","bitset"],"priority":0,"source":"CF","link":[["LG","https://www.luogu.com.cn/problem/CF254D"],["CF","http://codeforces.com/problemset/problem/254/D"]],"pswd":false,"date":"2021-06-30 18:34","content":"## 题面翻译\n\n一个 $N\\times M$ 的网格图中，有一些格子是墙，用 $X$ 表示，其余格子中，有一些格子中有**老鼠**，用 $R$ 表示，其余空格子用 `.` 表示\n\n现在需要放置两颗**手榴弹**，每颗手榴弹初始在格子 $(r_i,c_i)$ 上，在 $1\\sim D$ 秒内，每过 $1$ 秒其伤害范围会从现有的每个伤害范围的格子向外扩展一格，即若 $(a,b)$ 为伤害范围，则下一秒 $(a+1,b),(a-1,b),(a,b+1),(a,b-1)$ 中不为墙的格子都会变为伤害范围，当一个有老鼠的格子成为伤害范围，那个格子的老鼠就会死掉\n\n你需要给出能够杀死所有老鼠的两个手榴弹的放置坐标 $(r_1,c_1)$ 和 $(r_2,c_2)$，如果无解，则输出 $-1$\n\n## 题解\n考虑如果老鼠的数量大于 $290$ 那么一定不能全部炸死。只需要考虑老鼠的数量 $\\le 290$。先计算出每个位置能炸到的老鼠存在 $\\rm bitset$ 里，如果炸不到就不用管了。那么显然最多就 $145\\times 290$ 个这样的点。于是先枚举能炸到第一个老鼠的点，第一个炸弹只能在这些位置，再去枚举第二个位置，把两个位置能炸到的老鼠取交集，也就是 $\\rm bitset$ 的或。\n\n复杂度主要是后面的 $\\mathcal{O}(\\frac{290\\times145\\times290\\times290}w)$。\n\n## 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+10,M=150;\nconst int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\nint n,m,d;char mp[N][N];\nint id[N][N],cnt,xx[2*M*M],yy[2*M*M];\nbitset<2*M>flag[2*M*M];bool vis[N][N];\nvoid add(int x,int y,int id){\n\tint&a=::id[x][y];\n\tif(!a)a=++cnt,xx[a]=x,yy[a]=y;\n\tflag[a].set(id,1);\n}\n#define In(a,b) (1<=(a)&&(a)<=n&&1<=(b)&&(b)<=m)\nvoid bfs(int x,int y,int id){\n\tqueue<tuple<int,int,int>>q;q.push({x,y,0});\n\twhile(q.size()){\n\t\tauto [x,y,dp]=q.front();q.pop();\n\t\tadd(x,y,id);if(dp==d)continue;++dp;\n\t\tfor(int i=0;i<4;i++)if(In(x+dx[i],y+dy[i])&&mp[x+dx[i]][y+dy[i]]!='X')\n\t\t\tq.push({x+dx[i],y+dy[i],dp});\n\t}\n}\nsigned main(){\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n\t\n\tint rats=0;\n\tscanf(\"%d%d%d\",&n,&m,&d);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%s\",mp[i]+1);\n\t\tfor(int j=1;j<=m;j++)\n\t\t\trats+=mp[i][j]=='R';\n\t}\n\tif(rats>290)return puts(\"-1\"),0;\n\trats=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tif(mp[i][j]=='R')bfs(i,j,++rats);\n\tfor(int i=1;i<=cnt;i++)\n\t\tif(flag[i].count()==rats){\n\t\t\tfor(int x=1;x<=n;x++)\n\t\t\t\tfor(int y=1;y<=m;y++)\n\t\t\t\t\tif((x!=xx[i]||y!=yy[i])&&mp[x][y]!='X')\n\t\t\t\t\t\treturn printf(\"%d %d %d %d\\n\",xx[i],yy[i],x,y),0;\n\t\t\treturn puts(\"-1\"),0;\n\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tif(mp[i][j]=='R'){\n\t\t\t\tqueue<tuple<int,int,int>>q;q.push({i,j,0});\n\t\t\t\twhile(q.size()){\n\t\t\t\t\tauto [x,y,dp]=q.front();q.pop();\n\t\t\t\t\tvis[x][y]=1;\n\t\t\t\t\tfor(int k=1;k<=cnt;k++)\n\t\t\t\t\t\tif((flag[id[x][y]]|flag[k]).count()==rats)\n\t\t\t\t\t\t\treturn printf(\"%d %d %d %d\\n\",x,y,xx[k],yy[k]),0;\n\t\t\t\t\tif(dp==d)continue;++dp;\n\t\t\t\t\tfor(int i=0;i<4;i++)if(In(x+dx[i],y+dy[i])&&mp[x+dx[i]][y+dy[i]]!='X'&&!vis[x+dx[i]][y+dy[i]])\n\t\t\t\t\t\tq.push({x+dx[i],y+dy[i],dp});\n\t\t\t\t}\n\t\t\t\treturn puts(\"-1\"),0;\n\t\t\t}\n}\n```"}