{"title":"CF264E Roadside Trees","file":"CF264E.json","pic":"/bg/96.jpg","tag":["LIS","暴力"],"priority":0,"source":"CF","link":[["LG","https://www.luogu.com.cn/problem/CF264E"],["CF","https://codeforces.com/problemset/problem/264/E"]],"pswd":false,"date":"2021-06-26 13:34","content":"## 题面翻译\n\n在 $1\\sim n$ 的位置能种树，刚开始能种树。  \n\n第 $i$ 个时刻会有操作：  \n\n1. 在一个没种过树的位置 $p_i$ 种一颗高度为 $h_i$ 的树。  \n2. 砍掉第 $x_i$ 棵树，保证这个位置以后不会种树。 \n \n每天树会长高 $1$\n\n每执行一次操作，输出最长上升子序列长度  \n\n任意时刻树的高度不同\n\n\n## 题解\n首先把所有的 $h_i$ 减去 $i$ 就可以消去树生长的影响，比较容易想到。\n\n在每一棵树上记录最长上升子序列长度 $dp_i$。\n\n然后 $1\\le h_i\\le 10$ 说明只有 $10$ 棵比它低，也就是说只有 $10$ 个位置的 $dp$ 值会改变。\n\n$1\\le x_i\\le 10$ 同理。$dp$ 值需要用数据结构维护一下。\n## 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10,M=2e5+10;\nint n,m;\n#define Range1 1,-m-10,20\n#define Range2 1,1,n\n#define chkmx(a,b) (a)=max((a),(b))\n#define chkmn(a,b) (a)=min((a),(b))\n#define pb push_back\nstruct SGT{\n\t#define mid ((l+r)>>1)\n\t#define lc (x<<1)\n\t#define rc (x<<1|1)\n\t#define mx v[x]\n\tsigned v[N<<3];\n\tvoid up(int x){mx=max(v[lc],v[rc]);}\n\tvoid upd(int x,int l,int r,int pos,int val){return l==r?void(mx=val):((pos<=mid?upd(lc,l,mid,pos,val):upd(rc,mid+1,r,pos,val)),up(x));}\n\tint qry(int x,int l,int r,int mn){\n\t\tif(mn<=l)return mx;\n\t\tif(r<mn)return 0;\n\t\treturn max(qry(lc,l,mid,mn),qry(rc,mid+1,r,mn));\n\t}\n}A,B;\nint dp[N],ht[N];\n//B的下标为位置，A为高度 \nset<int>pos;\nset<pair<int,int> >hei;\nmultiset<int>suf;\nvoid add(int pos,int val){\n\tdp[pos]=val;\n\t::pos.insert(pos);\n\thei.insert({ht[pos],pos});\n\tsuf.insert(val);\n\tA.upd(Range1,ht[pos],val);\n\tB.upd(Range2,pos,val);\n}\nvoid del(int pos){\n\t::pos.erase(pos);\n\thei.erase({ht[pos],pos});\n\tsuf.erase(suf.lower_bound(dp[pos]));\n\tdp[pos]=0;\n\tA.upd(Range1,ht[pos],0);\n\tB.upd(Range2,pos,0);\n}\nsigned main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++){\n\t\tint op;scanf(\"%d\",&op);\n\t\tif(op==1){\n\t\t\tint p,h;scanf(\"%d%d\",&p,&h);\n\t\t\tht[p]=h-=i;\n\t\t\tvector<int>num;\n\t\t\tfor(auto [H,P]:hei){\n\t\t\t\tif(H>h)break;\n\t\t\t\tnum.pb(P);\n\t\t\t}\n\t\t\tfor(auto P:num)\n\t\t\t\tdel(P);\n\t\t\treverse(num.begin(),num.end());\n\t\t\tadd(p,B.qry(Range2,p+1)+1);\n\t\t\tfor(auto P:num)\n\t\t\t\tadd(P,B.qry(Range2,P+1)+1);\n\t\t}else{\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tvector<int>num;\n\t\t\tfor(auto P:pos){\n\t\t\t\tx--;\n\t\t\t\tif(!x){\n\t\t\t\t\tdel(P);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum.pb(P);\n\t\t\t}\n\t\t\tfor(auto P:num)\n\t\t\t\tdel(P);\n\t\t\treverse(num.begin(),num.end());\n\t\t\tfor(auto P:num)\n\t\t\t\tadd(P,A.qry(Range1,ht[P]+1)+1);\n\t\t}\n\t\tif(!suf.size())puts(\"0\");else printf(\"%d\\n\",*suf.rbegin());\n\t}\n}\n```"}