{"title":"CF1542D Priority Queue","file":"CF1542D.json","pic":"/bg/55.jpg","tag":["dp","组合"],"priority":0,"source":"CF","link":[["LG","https://www.luogu.com.cn/problem/CF1542D"],["CF","https://codeforces.com/problemset/problem/1542/D"]],"pswd":false,"date":"2021-07-04 08:02","content":"## 题面翻译\n\n给定一个序列 $A$，$A$ 的每一个元素形如 `+ x` 和 `-`，其中 $x$ 为一个整数。\n\n对于一个每个元素都形如 `+ x` 和 `-` 的序列 $S$，按如下方式计算 $f(S)$ 的值：\n\n- 你需要依次遍历 $S$ 中的元素，并且维护一个可重集 $T$。\n\n- 对于每个 $S$ 中的元素，若其为 `+ x`，那么就将 $x$ 加入 $T$，否则就删除 $T$ 最小的数。特别的，若 $T$ 中没有数，那么就不进行删除操作。\n\n- 在遍历完 $S$ 中的元素后，将可重集 $T$ 中所有数的和 $sum$ 算出来。$sum$ 即为 $f(S)$ 的值。\n\n定义 $b$ 是 $a$ 的子序列当且仅当 $b$ 是由 $a$ 在不改变原有顺序的情况下删除若干元素得到的。现在对于 $A$ 的所有子序列 $B$，蓝想让你求出 $f(B)$ 的和模 $998244353$ 的值。\n\n本题有 $1 \\leq n \\leq 500$，并且对于每个形如 `+ x` 元素中的 $x$，有 $1 \\leq x < 998244353$。\n\n## 题解\n\n定义一个数更小当且仅当：\n\n1. 数更小\n2. 数相等，位置更前\n\n于是就考虑第 $a$ 数最后还在 $S$ 里的方案数。来 $\\rm dp$，考虑到位置 $i$，有 $j$ 个比 $x_a$ 小的方案数 $dp[i][j]$。于是随便转移一下就好了。\n## 代码\n```cpp\n// Problem: D. Priority Queue\n// Contest: Codeforces - Codeforces Round #729 (Div. 2)\n// URL: https://codeforces.ml/contest/1542/problem/D\n// Memory Limit: 512 MB\n// Time Limit: 3000 ms\n//\n// Powered by CP Editor (https://cpeditor.org)\n \n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<const int mod>\nstruct modint {\n\tint x;\n\tmodint<mod>(int o = 0) {\n\t\tx = o;\n\t}\n\tmodint<mod> &operator = (int o) {\n\t\treturn x = o, *this;\n\t}\n\tmodint<mod> &operator +=(modint<mod> o) {\n\t\treturn x = x + o.x >= mod ? x + o.x - mod : x + o.x, *this;\n\t}\n\tmodint<mod> &operator -=(modint<mod> o) {\n\t\treturn x = x - o.x < 0 ? x - o.x + mod : x - o.x, *this;\n\t}\n\tmodint<mod> &operator *=(modint<mod> o) {\n\t\treturn x = 1ll * x * o.x % mod, *this;\n\t}\n\tmodint<mod> &operator ^=(int b) {\n\t\tmodint<mod> a = *this, c = 1;\n\t\tfor (; b; b >>= 1, a *= a)\n\t\t\tif (b & 1)\n\t\t\t\tc *= a;\n\t\treturn x = c.x, *this;\n\t}\n\tmodint<mod> &operator /=(modint<mod> o) {\n\t\treturn *this *= o ^= mod - 2;\n\t}\n\tmodint<mod> &operator +=(int o) {\n\t\treturn x = x + o >= mod ? x + o - mod : x + o, *this;\n\t}\n\tmodint<mod> &operator -=(int o) {\n\t\treturn x = x - o < 0 ? x - o + mod : x - o, *this;\n\t}\n\tmodint<mod> &operator *=(int o) {\n\t\treturn x = 1ll * x * o % mod, *this;\n\t}\n\tmodint<mod> &operator /=(int o) {\n\t\treturn *this *= ((modint<mod>(o)) ^= mod - 2);\n\t}\n\ttemplate<class I>friend modint<mod> operator +(modint<mod> a, I b) {\n\t\treturn a += b;\n\t}\n\ttemplate<class I>friend modint<mod> operator -(modint<mod> a, I b) {\n\t\treturn a -= b;\n\t}\n\ttemplate<class I>friend modint<mod> operator *(modint<mod> a, I b) {\n\t\treturn a *= b;\n\t}\n\ttemplate<class I>friend modint<mod> operator /(modint<mod> a, I b) {\n\t\treturn a /= b;\n\t}\n\tfriend modint<mod> operator ^(modint<mod> a, int b) {\n\t\treturn a ^= b;\n\t}\n\tfriend bool operator ==(modint<mod> a, int b) {\n\t\treturn a.x == b;\n\t}\n\tfriend bool operator !=(modint<mod> a, int b) {\n\t\treturn a.x != b;\n\t}\n\tbool operator ! () {\n\t\treturn !x;\n\t}\n\tmodint<mod> operator - () {\n\t\treturn x ? mod - x : 0;\n\t}\n};\ntypedef modint<998244353> mint;\n#define int long long\nconst int N = 600;\nint n;\nchar op[N];\nint x[N];\nmint dp[N][N];\n \nsigned main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\top[i] = getchar();\n\t\twhile (op[i] != '+' && op[i] != '-')\n\t\t\top[i] = getchar();\n\t\tif (op[i] == '+')\n\t\t\tscanf(\"%d\", &x[i]);\n\t}\n\tmint ans = 0;\n\t//计算每一个的贡献\n\tfor (int i = 1; i <= n; i++)\n\t\tif (op[i] == '+') {\n\t\t\t//定义一个数更小：值更小 位置更前\n\t\t\tmemset(dp, 0, sizeof dp);\n\t\t\tdp[0][0] = 1;\n\t\t\tfor (int j = 1; j < i; j++)\n\t\t\t\tfor (int k = 0; k <= j; k++) {\n\t\t\t\t\tif (op[j] == '-') {\n\t\t\t\t\t\tif (k != 0)\n\t\t\t\t\t\t\tdp[j][k] = dp[j - 1][k + 1] + dp[j - 1][k];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[j][k] = dp[j - 1][k + 1] + dp[j - 1][k] * 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (x[j] > x[i])\n\t\t\t\t\t\t\tdp[j][k] = dp[j - 1][k] * 2;\n\t\t\t\t\t\telse if (k != 0)\n\t\t\t\t\t\t\tdp[j][k] = dp[j - 1][k - 1] + dp[j - 1][k];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[j][k] = dp[j - 1][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif (i == n) {\n\t\t\t\tfor (int k = 0; k <= n; k++)\n\t\t\t\t\tans += x[i] * dp[i - 1][k];\n\t\t\t} else {\n\t\t\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\t\t\tint pre = j - 1;\n\t\t\t\t\tif (j == i + 1)\n\t\t\t\t\t\tpre = i - 1;\n\t\t\t\t\tfor (int k = 0; k <= j; k++) {\n\t\t\t\t\t\tif (op[j] == '-') {\n\t\t\t\t\t\t\tdp[j][k] = dp[pre][k + 1] + dp[pre][k];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (x[j] >= x[i])\n\t\t\t\t\t\t\t\tdp[j][k] = dp[pre][k] * 2;\n\t\t\t\t\t\t\telse if (k != 0)\n\t\t\t\t\t\t\t\tdp[j][k] = dp[pre][k - 1] + dp[pre][k];\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tdp[j][k] = dp[pre][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k <= n; k++)\n\t\t\t\t\tans += x[i] * dp[n][k];\n\t\t\t\t\t//cout<<x[i]<<\" \"<<dp[n][k].x<<endl;;\n\t\t\t}\n\t\t\t//cout << ans.x<<endl;;\n\t\t}\n\tcout << ans.x;\n}\n```"}