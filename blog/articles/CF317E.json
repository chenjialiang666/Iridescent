{"title":"CF317E Princess and Her Shadow","file":"CF317E.json","pic":"/bg/5.jpg","tag":["暴力"],"priority":0,"source":"CF","link":[["LG","https://www.luogu.com.cn/problem/CF317E"],["CF","https://codeforces.com/problemset/problem/317/E"]],"pswd":false,"date":"2021-06-23 21:38","content":"## 题面翻译\n\n平面直角坐标系上，有一个公主和她的影子，还有 $m$ 棵树，公主在 $(v_x,v_y)$ ,影子在 $(s_x,s_y)$ 。  \n公主要去追影子。  \n公主向右走，影子就会向右走；公主向左走，影子就会向左走；公主向上走，影子就会向上走；公主向下走，影子就会向下走。  \n如果影子前进的方向是一棵树，影子就不会动。公主不能撞树。  \n求一组公主的行动方案，让公主抓到影子，要求方案长度不能超过 $10^6$ 。若无解，输出 $-1$。\n\n## 题解\n考虑 $400$ 棵树能否把公主和影子围起来。\n\n如果两者皆不封闭，那么一定可以把两者都移到外面，都移到外面之后就一定有解，这部分可以手玩一下。如果一个封闭一个不封闭，显然无解。\n\n如果两个都封闭，那么联通就必定有解。把公主移到影子在的地方，然后继续搜索。\n## 代码\n```cpp\n#include<bits/stdc++.h>\n#define mp make_pair\n#define pii pair<int,int>\n#define ppp pair<pii,pii>\n#define L 0\n#define R 1\n#define D 2\n#define U 3\n#define vvx now.first.first\n#define vvy now.first.second\n#define ssx now.second.first\n#define ssy now.second.second\n#define mnx min(vvx,ssx)\n#define mxx max(vvx,ssx)\n#define mny min(vvy,ssy)\n#define mxy max(vvy,ssy)\nusing namespace std;\nint vx,vy,sx,sy,m;\nint vis[450][450];\nint flag[450][450];\nint x[450],y[450];\nconst int dx[4]={0,0,-1,1};\nconst int dy[4]={-1,1,0,0};\nconst char ch[4]={'L','R','D','U'};\nbool In(int x,int y){return x>=5&&x<=440&&y>=5&&y<=440;}\nbool Not(int x,int y){\n\tif(!In(x,y))return false;\n\treturn vis[x][y];\n}\nbool fb(int x,int y){\n\tmemset(flag,0,sizeof flag);\n\tqueue<pii>q;q.push(mp(x,y));flag[x][y]=1;\n\twhile(q.size()){\n\t\tauto [x,y]=q.front();q.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\t\tif(!In(xx,yy))return false;\n\t\t\tif(vis[xx][yy])continue;\n\t\t\tif(flag[xx][yy])continue;\n\t\t\tflag[xx][yy]=1;\n\t\t\tq.push(mp(xx,yy));\n\t\t}\n\t}return true;\n}\nppp work(ppp A,int dir){\n\tauto [x,y]=A.first;auto [xx,yy]=A.second;\n\tif(Not(x+dx[dir],y+dy[dir]))exit(-1);\n\tx+=dx[dir],y+=dy[dir];\n\tif(!Not(xx+dx[dir],yy+dy[dir]))xx+=dx[dir],yy+=dy[dir];\n\tputchar(ch[dir]);\n\tif(x==xx&&y==yy)exit(0);\n\treturn mp(mp(x,y),mp(xx,yy));\n} \nppp work(ppp A,int dir,int times){\n\twhile(times--)\n\t\tA=work(A,dir);\n\treturn A;\n}\nppp now;\nvoid dfs(int x,int y){\n\t//printf(\"%d %d\\n\",x-210,y-210);\n\tif(flag[x][y]!=-10){\n\t\tint dir=flag[x][y]^1;\n\t\tdfs(x+dx[dir],y+dy[dir]);\n\t}else return;\n\tnow=work(now,flag[x][y]);\n}\nsigned main(){\n\t//freopen(\"1.out\",\"w\",stdout);\n\tscanf(\"%d%d%d%d%d\",&vx,&vy,&sx,&sy,&m);\n\tif(!m){\n\t\tif(vx==sx&&vy==sy)return 0;\n\t\treturn puts(\"-1\"),0;\n\t}\n\tvx+=210,vy+=210,sx+=210,sy+=210;\n\tswap(vx,vy);swap(sx,sy);\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&y[i],&x[i]);\n\t\tx[i]+=210;y[i]+=210;\n\t\tvis[x[i]][y[i]]=1;\n\t}\n\tbool V=fb(vx,vy);\n\tbool S=fb(sx,sy);\n\tif(V^S)\n\t\treturn puts(\"-1\"),0;\n\tif(V&&S){\n\t\t{\n\t\t\tmemset(flag,0,sizeof flag);\n\t\t\tqueue<pii>q;q.push(mp(vx,vy));flag[vx][vy]=0;\n\t\t\twhile(q.size()){\n\t\t\t\tauto [x,y]=q.front();q.pop();\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\t\t\t\tif(vis[xx][yy])continue;\n\t\t\t\t\tif(flag[xx][yy])continue;\n\t\t\t\t\tif(xx==sx&&yy==sy)\n\t\t\t\t\t\tgoto loop;\n\t\t\t\t\tflag[xx][yy]=1;\n\t\t\t\t\tq.push(mp(xx,yy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn puts(\"-1\"),0;\n\t\tloop:;\n\t\tfor(;;){\n\t\t\tmemset(flag,0xff,sizeof flag);\n\t\t\t//flag记录dir \n\t\t\tflag[vx][vy]=-10;\n\t\t\tqueue<pii>q;q.push(mp(vx,vy));\n\t\t\twhile(q.size()){\n\t\t\t\tauto [x,y]=q.front();q.pop();\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\t\t\t\tif(vis[xx][yy])continue;\n\t\t\t\t\tif(flag[xx][yy]!=-1)continue;\n\t\t\t\t\tflag[xx][yy]=i;\n\t\t\t\t\tif(xx==sx&&yy==sy)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\tq.push(mp(xx,yy));\n\t\t\t\t}\n\t\t\t}\n\t\t\tout:;\n\t\t\tnow=mp(mp(vx,vy),mp(sx,sy));\n\t\t\t\n\t\t\tdfs(sx,sy);\n\t\t\t//putchar('\\n');\n\t\t\tvx=now.first.first;\n\t\t\tvy=now.first.second;\n\t\t\t\n\t\t\tsx=now.second.first;\n\t\t\tsy=now.second.second;\n\t\t\tif(vx==sx&&vy==sy)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\tmemset(flag,0xff,sizeof flag);\n\t//flag记录dir \n\tint ex,ey;\n\tflag[vx][vy]=-10;\n\tqueue<pii>q;q.push(mp(vx,vy));\n\twhile(q.size()){\n\t\tauto [x,y]=q.front();q.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\t\tif(vis[xx][yy])continue;\n\t\t\tif(flag[xx][yy]!=-1)continue;\n\t\t\tflag[xx][yy]=i;\n\t\t\tif(!In(xx,yy)){\n\t\t\t\tex=xx,ey=yy;\n\t\t\t\tgoto out2;\n\t\t\t}\n\t\t\tq.push(mp(xx,yy));\n\t\t}\n\t}\n\tout2:;\n\tnow=mp(mp(vx,vy),mp(sx,sy));\n\tdfs(ex,ey);\n\t\n\tif(ex==441)now=work(now,L,500),now=work(now,D,500);\n\telse now=work(now,D,500),now=work(now,L,500);\n\tnow=work(now,D,500),now=work(now,L,500);\n\t\n\tsx=now.second.first;\n\tsy=now.second.second;\n\tif(In(sx,sy)){\n\t\tint ex,ey;\n\t\tmemset(flag,0xff,sizeof flag);\n\t\tflag[sx][sy]=-10;\n\t\twhile(q.size())q.pop();\n\t\tq.push(mp(sx,sy));\n\t\twhile(q.size()){\n\t\t\tauto [x,y]=q.front();q.pop();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\t\t\tif(vis[xx][yy])continue;\n\t\t\t\tif(flag[xx][yy]!=-1)continue;\n\t\t\t\tflag[xx][yy]=i;\n\t\t\t\tif(!In(xx,yy)){\n\t\t\t\t\tex=xx,ey=yy;\n\t\t\t\t\tgoto out3;\n\t\t\t\t}\n\t\t\t\tq.push(mp(xx,yy));\n\t\t\t}\n\t\t}\n\t\tout3:;\n\t\tdfs(ex,ey);\n\t\t\n\t\tif(ex==441)now=work(now,L,500),now=work(now,D,500);\n\t\telse now=work(now,D,500),now=work(now,L,500);\n\t}\n\tif(ssx>=vvx&&ssy>=vvy){\n\t\tint mn=0x3f3f3f3f;\n\t\tfor(int i=1;i<=m;i++)mn=min(mn,x[i]);\n\t\twhile(ssx!=mn)\n\t\t\tnow=work(now,U);\n\t\twhile(!Not(ssx+dx[R],ssy+dy[R]))\n\t\t\tnow=work(now,R);\n\t\twhile(vvy!=ssy)\n\t\t\tnow=work(now,R);\n\t\tnow=work(now,D);\n\t\tnow=work(now,R);\n\t\twhile(1)now=work(now,U);\n\t}\n\tif(ssx>=vvx&&ssy<=vvy){\n\t\twhile(ssy<=440)now=work(now,R);\n\t\tint mn=0x3f3f3f3f;\n\t\tfor(int i=1;i<=m;i++)mn=min(mn,x[i]);\n\t\twhile(ssx!=mn)\n\t\t\tnow=work(now,U);\n\t\twhile(!Not(ssx+dx[L],ssy+dy[L]))\n\t\t\tnow=work(now,L);\n\t\twhile(vvy!=ssy)\n\t\t\tnow=work(now,L);\n\t\tnow=work(now,D);\n\t\tnow=work(now,L);\n\t\twhile(1)now=work(now,U);\n\t}\n\tif(ssx<=vvx&&ssy<=vvy){\n\t\twhile(ssy<=440)now=work(now,R);\n\t\tint mx=-0x3f3f3f3f;\n\t\tfor(int i=1;i<=m;i++)mx=max(mx,x[i]);\n\t\twhile(ssx!=mx)\n\t\t\tnow=work(now,U);\n\t\twhile(!Not(ssx+dx[L],ssy+dy[L]))\n\t\t\tnow=work(now,L);\n\t\twhile(vvy!=ssy)\n\t\t\tnow=work(now,L);\n\t\tnow=work(now,U);\n\t\tnow=work(now,L);\n\t\twhile(1)now=work(now,D);\n\t}\n\tif(ssx<=vvx&&ssy>=vvy){\n\t\tint mx=-0x3f3f3f3f;\n\t\tfor(int i=1;i<=m;i++)mx=max(mx,x[i]);\n\t\twhile(ssx!=mx)\n\t\t\tnow=work(now,U);\n\t\twhile(!Not(ssx+dx[R],ssy+dy[R]))\n\t\t\tnow=work(now,R);\n\t\twhile(vvy!=ssy)\n\t\t\tnow=work(now,R);\n\t\tnow=work(now,U);\n\t\tnow=work(now,R);\n\t\twhile(1)now=work(now,D);\n\t}\n}\n```"}